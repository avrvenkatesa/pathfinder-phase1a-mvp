import express from 'express';
import rateLimit from 'express-rate-limit';
import passport from 'passport';
import jwt from 'jsonwebtoken';
import { isAuthenticated } from './auth-setup';
import { storage } from './storage';
import { sendSuccess, sendError, asyncHandler } from '../../../shared/utils/response-helpers';
import { getEmailService } from '../../../shared/utils/email-service';
import {
  loginSchema,
  registerSchema,
  forgotPasswordSchema,
  resetPasswordSchema,
  changePasswordSchema,
  setupMfaSchema,
  verifyMfaSetupSchema,
  verifyMfaSchema,
  disableMfaSchema,
  type AuthResponse,
  type MfaSetupResponse,
  type UserProfile
} from '../../../shared/types/auth';
import {
  PasswordUtils,
  SessionUtils,
  TokenUtils,
  AuditUtils,
  PermissionUtils,
  LockoutUtils
} from '../../../shared/utils/auth-utils';

// Rate limiting
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 20, // limit each IP to 20 auth requests per windowMs
  message: {
    success: false,
    error: 'RATE_LIMIT_EXCEEDED',
    message: 'Too many authentication attempts, please try again later.',
  },
});

const generalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes  
  max: 200, // limit each IP to 200 requests per windowMs
  message: {
    success: false,
    error: 'RATE_LIMIT_EXCEEDED',
    message: 'Too many requests, please try again later.',
  },
});

const strictLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // Very strict for sensitive operations
  message: {
    success: false,
    error: 'RATE_LIMIT_EXCEEDED', 
    message: 'Too many attempts, please try again later.',
  },
});

// JWT Helper
function generateJWT(user: any, sessionId?: string): string {
  const payload = {
    sub: user.id,
    email: user.email,
    role: user.role,
    sessionId,
    jti: TokenUtils.generateSecureToken(16), // JWT ID for blacklisting
  };

  return jwt.sign(payload, process.env.JWT_SECRET || 'your-secret-key', {
    expiresIn: '24h',
        resource: 'auth',
        details: { permission, route: req.path },
// Middleware to check permissions
function requirePermission(permission: string) {
  return async (req: any, res: any, next: any) => {
    if (!req.user) {
      return sendError(res, 401, 'UNAUTHORIZED', 'Authentication required');
    }

    const hasPermission = PermissionUtils.hasPermission(req.user.role, permission as any);
    if (!hasPermission) {
      await storage.createAuditLog(AuditUtils.createAuditLog({
        userId: req.user.id,
        action: 'permission_denied',
        resource: 'auth',
        details: { permission, route: req.path },
        ipAddress: AuditUtils.getClientIP(req),
        userAgent: req.get('User-Agent'),
        success: false,
        errorMessage: 'Insufficient permissions',
      }));
      
      return sendError(res, 403, 'FORBIDDEN', 'Insufficient permissions');
    }

    next();
  };
}

// Authentication middleware for JWT
function jwtAuth(req: any, res: any, next: any) {
  passport.authenticate('jwt', { session: false }, (err: any, user: any) => {
    if (err) {
      return next(err);
    }
    if (!user) {
      return sendError(res, 401, 'UNAUTHORIZED', 'Invalid or expired token');
    }
    req.user = user;
    next();
  })(req, res, next);
}

export function setupRoutes(app: express.Express) {
  const router = express.Router();

  // ===================
  // AUTHENTICATION ENDPOINTS
  // ===================

  /**
   * @swagger
   * /api/auth/register:
   *   post:
   *     summary: Register a new user
   *     tags: [Authentication]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             properties:
   *               email:
   *                 type: string
   *                 format: email
   *               password:
   *                 type: string
   *                 minLength: 8
   *               firstName:
   *                 type: string
   *               lastName:
   *                 type: string
   *               confirmPassword:
   *                 type: string
   *     responses:
   *       201:
   *         description: User registered successfully
   *       400:
   *         description: Validation error
   *       409:
   *         description: Email already exists
   */
  router.post('/register', authLimiter, asyncHandler(async (req, res) => {
    try {
      const validatedData = registerSchema.parse(req.body);
      
      // Check if user already exists
      const existingUser = await storage.getUserByEmail(validatedData.email);
      if (existingUser) {
        await storage.createAuditLog(AuditUtils.createAuditLog({
          action: 'register_failed',
          resource: 'user',
          details: { email: validatedData.email, reason: 'email_exists' },
          ipAddress: AuditUtils.getClientIP(req),
          userAgent: req.get('User-Agent'),
          success: false,
          errorMessage: 'Email already exists',
        }));
        
        return sendError(res, 409, 'EMAIL_EXISTS', 'Email already registered');
      }

      // Create user
      const newUser = await storage.createUser({
        email: validatedData.email,
        password: validatedData.password,
        firstName: validatedData.firstName,
        lastName: validatedData.lastName,
        role: 'user',
      });

      // Generate email verification token
      const verificationToken = await storage.generateEmailVerificationToken(newUser.id);

      // Send welcome email with verification link
      const emailService = getEmailService();
      await emailService.sendWelcomeEmail(
        newUser.email!,
        newUser.firstName || 'User',
        verificationToken
      );

      await storage.createAuditLog(AuditUtils.createAuditLog({
        userId: newUser.id,
        action: 'user_registered',
        resource: 'user',
        details: { email: newUser.email, firstName: newUser.firstName, lastName: newUser.lastName },
        ipAddress: AuditUtils.getClientIP(req),
        userAgent: req.get('User-Agent'),
        success: true,
      }));

      const response: AuthResponse = {
        success: true,
        user: {
          id: newUser.id,
          email: newUser.email!,
          firstName: newUser.firstName || '',
          lastName: newUser.lastName || '',
          role: newUser.role!,
          mfaEnabled: newUser.mfaEnabled,
          emailVerified: newUser.emailVerified,
        },
        message: 'Registration successful! Please check your email to verify your account.',
      };

      return res.status(201).json(response);
    } catch (error: any) {
      if (error.name === 'ZodError') {
        return sendError(res, 400, 'VALIDATION_ERROR', error.issues[0].message);
      }
      console.error('Registration error:', error);
      return sendError(res, 500, 'INTERNAL_ERROR', 'Registration failed');
    }
  }));

  /**
   * @swagger
   * /api/auth/login:
   *   post:
   *     summary: Login with email and password
   *     tags: [Authentication]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             properties:
   *               email:
   *                 type: string
   *                 format: email
   *               password:
   *                 type: string
   *               rememberMe:
   *                 type: boolean
   *               mfaCode:
   *                 type: string
   *     responses:
   *       200:
   *         description: Login successful
   *       401:
   *         description: Invalid credentials or MFA required
   */
  router.post('/login', authLimiter, asyncHandler(async (req, res) => {
    try {
      const validatedData = loginSchema.parse(req.body);
      
      const user = await storage.getUserByEmail(validatedData.email);
      
      if (!user) {
        await storage.createAuditLog(AuditUtils.createAuditLog({
          action: 'login_failed',
          resource: 'user',
          details: { email: validatedData.email, reason: 'user_not_found' },
          ipAddress: AuditUtils.getClientIP(req),
          userAgent: req.get('User-Agent'),
          success: false,
          errorMessage: 'User not found',
        }));
        
        return sendError(res, 401, 'INVALID_CREDENTIALS', 'Invalid email or password');
      }

      // Check if account is locked
      if (LockoutUtils.isAccountLocked(user.lockedUntil)) {
        const remainingTime = LockoutUtils.getRemainingLockoutTime(user.lockedUntil!);
        const minutesRemaining = Math.ceil(remainingTime / (1000 * 60));
        
        return sendError(res, 423, 'ACCOUNT_LOCKED', `Account locked. Try again in ${minutesRemaining} minute(s).`);
      }

      // Verify password
      if (!user.password || !(await PasswordUtils.verify(validatedData.password, user.password))) {
        const failedAttempts = parseInt(user.failedLoginAttempts || '0') + 1;
        const shouldLock = LockoutUtils.shouldLockAccount(failedAttempts);
        
        await storage.updateUser(user.id, {
          failedLoginAttempts: failedAttempts.toString(),
          lockedUntil: shouldLock ? LockoutUtils.calculateLockoutExpiry() : undefined,
        });

        const message = shouldLock 
          ? 'Too many failed attempts. Account has been locked for 30 minutes.'
          : 'Invalid email or password';
          
        return sendError(res, 401, 'INVALID_CREDENTIALS', message);
      }

      // Check MFA if enabled
      if (user.mfaEnabled && !validatedData.mfaCode) {
        const response: AuthResponse = {
          success: false,
          requiresMfa: true,
          message: 'MFA code required',
        };
        return res.status(200).json(response);
      }

      if (user.mfaEnabled && validatedData.mfaCode) {
        const verified = await storage.verifyMfaCode(user.id, validatedData.mfaCode);
        
        if (!verified) {
          // Check backup code
          const backupCodeValid = await storage.verifyAndUseBackupCode(user.id, validatedData.mfaCode);
          if (!backupCodeValid) {
            return sendError(res, 401, 'INVALID_MFA_CODE', 'Invalid MFA code');
          }
        }
      }

      // Create session
      const sessionToken = SessionUtils.generateSessionId();
      const refreshToken = SessionUtils.generateRefreshToken();
      const expiresAt = SessionUtils.calculateExpiryTime(validatedData.rememberMe);
      
      const session = await storage.createSession({
        userId: user.id,
        sessionToken,
        refreshToken,
        deviceInfo: SessionUtils.parseUserAgent(req.get('User-Agent') || ''),
        ipAddress: AuditUtils.getClientIP(req),
        userAgent: req.get('User-Agent') || '',
        expiresAt,
      });

      // Generate JWT
      const accessToken = generateJWT(user, session.id);

      // Reset failed attempts
      await storage.updateUser(user.id, {
        failedLoginAttempts: '0',
        lockedUntil: null,
        lastLoginAt: new Date(),
      });

      await storage.createAuditLog(AuditUtils.createAuditLog({
        userId: user.id,
        action: 'login_success',
        resource: 'user',
        details: { email: user.email, mfaUsed: user.mfaEnabled },
        ipAddress: AuditUtils.getClientIP(req),
        userAgent: req.get('User-Agent'),
        success: true,
      }));

      const response: AuthResponse = {
        success: true,
        user: {
          id: user.id,
          email: user.email!,
          firstName: user.firstName || '',
          lastName: user.lastName || '',
          role: user.role!,
          mfaEnabled: user.mfaEnabled,
          emailVerified: user.emailVerified,
        },
        sessionId: session.id,
        accessToken,
        refreshToken: session.refreshToken!,
        message: 'Login successful',
      };

      return res.json(response);
    } catch (error: any) {
      if (error.name === 'ZodError') {
        return sendError(res, 400, 'VALIDATION_ERROR', error.issues[0].message);
      }
      console.error('Login error:', error);
      return sendError(res, 500, 'INTERNAL_ERROR', 'Login failed');
    }
  }));

  /**
   * @swagger
   * /api/auth/user:
   *   get:
   *     summary: Get current user (Replit compatibility)
   *     tags: [Authentication]
   *     security:
   *       - cookieAuth: []
   *     responses:
   *       200:
   *         description: User information
   *       401:
   *         description: Unauthorized
   */
  router.get('/user', generalLimiter, isAuthenticated, asyncHandler(async (req: any, res) => {
    try {
      const userId = req.user.claims?.sub || req.user.id;
      const user = await storage.getUser(userId);
      
      if (!user) {
        return sendError(res, 404, 'USER_NOT_FOUND', 'User not found');
      }

      return sendSuccess(res, user);
    } catch (error) {
      console.error("Error fetching user:", error);
      return sendError(res, 500, 'INTERNAL_ERROR', 'Failed to fetch user');
    }
  }));

  /**
   * @swagger
   * /api/auth/profile:
   *   get:
   *     summary: Get user profile with sessions and OAuth accounts
   *     tags: [Authentication]
   *     security:
   *       - bearerAuth: []
   *     responses:
   *       200:
   *         description: User profile information
   */
  router.get('/profile', generalLimiter, jwtAuth, asyncHandler(async (req: any, res) => {
    try {
      const user = await storage.getUserById(req.user.id);
      if (!user) {
        return sendError(res, 404, 'USER_NOT_FOUND', 'User not found');
      }

      const sessions = await storage.getUserSessions(user.id);
      
      const profile: UserProfile = {
        id: user.id,
        email: user.email!,
        firstName: user.firstName || '',
        lastName: user.lastName || '',
        role: user.role!,
        mfaEnabled: user.mfaEnabled,
        emailVerified: user.emailVerified,
        profileImageUrl: user.profileImageUrl,
        lastLoginAt: user.lastLoginAt?.toISOString(),
        createdAt: user.createdAt!.toISOString(),
        oauthAccounts: [], // TODO: Implement OAuth account fetching
        activeSessions: sessions.map(s => ({
          id: s.id,
          deviceInfo: s.deviceInfo || 'Unknown Device',
          ipAddress: s.ipAddress || 'Unknown',
          lastAccessed: s.lastAccessedAt!.toISOString(),
          isCurrentSession: s.id === req.user.sessionId,
        })),
      };

      return sendSuccess(res, profile);
    } catch (error) {
      console.error('Error fetching profile:', error);
      return sendError(res, 500, 'INTERNAL_ERROR', 'Failed to fetch profile');
    }
  }));

  /**
   * @swagger
   * /api/auth/verify:
   *   get:
   *     summary: Verify authentication status (Replit compatibility)
   *     tags: [Authentication]
   *     security:
   *       - cookieAuth: []
   *     responses:
   *       200:
   *         description: Authentication status
   *       401:
   *         description: Unauthorized
   */
  router.get('/verify', generalLimiter, isAuthenticated, asyncHandler(async (req: any, res) => {
    const userId = req.user.claims?.sub || req.user.id;
    return sendSuccess(res, {
      authenticated: true,
      userId,
    });
  }));

  /**
   * @swagger
   * /api/auth/session:
   *   get:
   *     summary: Get session information (Replit compatibility)
   *     tags: [Authentication]
   *     security:
   *       - cookieAuth: []
   *     responses:
   *       200:
   *         description: Session information
   *       401:
   *         description: Unauthorized
   */
  router.get('/session', generalLimiter, isAuthenticated, asyncHandler(async (req: any, res) => {
    const user = req.user;
    const sessionInfo = {
      userId: user.claims?.sub || user.id,
      email: user.claims?.email || user.email,
      expiresAt: user.expires_at,
      isAuthenticated: req.isAuthenticated(),
    };
    return sendSuccess(res, sessionInfo);
  }));

  // ===================
  // MFA ENDPOINTS
  // ===================

  /**
   * @swagger
   * /api/auth/mfa/setup:
   *   post:
   *     summary: Setup MFA for user
   *     tags: [MFA]
   *     security:
   *       - bearerAuth: []
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             properties:
   *               password:
   *                 type: string
   *     responses:
   *       200:
   *         description: MFA setup initiated
   */
  router.post('/mfa/setup', authLimiter, jwtAuth, asyncHandler(async (req: any, res) => {
    try {
      const validatedData = setupMfaSchema.parse(req.body);
      const user = await storage.getUserById(req.user.id);
      
      if (!user) {
        return sendError(res, 404, 'USER_NOT_FOUND', 'User not found');
      }

      // Verify current password
      if (!user.password || !(await PasswordUtils.verify(validatedData.password, user.password))) {
        return sendError(res, 401, 'INVALID_PASSWORD', 'Current password is incorrect');
      }

      // Generate MFA secret and QR code
      const mfaData = await storage.generateMfaSecret();
      
      await storage.createAuditLog(AuditUtils.createAuditLog({
        userId: user.id,
        action: 'mfa_setup_started',
        resource: 'user',
        details: { email: user.email },
        ipAddress: AuditUtils.getClientIP(req),
        userAgent: req.get('User-Agent'),
        success: true,
      }));

      const response: MfaSetupResponse = {
        success: true,
        qrCode: mfaData.qrCodeUrl,
        secret: mfaData.secret,
        message: 'Scan the QR code with your authenticator app',
      };

      return res.json(response);
    } catch (error: any) {
      if (error.name === 'ZodError') {
        return sendError(res, 400, 'VALIDATION_ERROR', error.issues[0].message);
      }
      console.error('MFA setup error:', error);
      return sendError(res, 500, 'INTERNAL_ERROR', 'MFA setup failed');
    }
  }));

  /**
   * @swagger
   * /api/auth/mfa/verify-setup:
   *   post:
   *     summary: Verify and complete MFA setup
   *     tags: [MFA]
   *     security:
   *       - bearerAuth: []
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             properties:
   *               token:
   *                 type: string
   *                 description: 6-digit TOTP code
   *               backupCodes:
   *                 type: array
   *                 items:
   *                   type: string
   *     responses:
   *       200:
   *         description: MFA setup completed
   */
  router.post('/mfa/verify-setup', authLimiter, jwtAuth, asyncHandler(async (req: any, res) => {
    try {
      const validatedData = verifyMfaSetupSchema.parse(req.body);
      const user = await storage.getUserById(req.user.id);
      
      if (!user) {
        return sendError(res, 404, 'USER_NOT_FOUND', 'User not found');
      }

      // Generate MFA secret (should be stored in session/cache in production)
      const mfaData = await storage.generateMfaSecret();
      
      // Verify the TOTP code
      const speakeasy = require('speakeasy');
      const verified = speakeasy.totp.verify({
        secret: mfaData.secret,
        encoding: 'base32',
        token: validatedData.token,
        window: 2,
      });

      if (!verified) {
        return sendError(res, 400, 'INVALID_MFA_CODE', 'Invalid verification code');
      }

      // Generate backup codes
      const backupCodes = TokenUtils.generateBackupCodes(10);
      
      // Enable MFA
      await storage.enableMfa(user.id, mfaData.secret, backupCodes);

      await storage.createAuditLog(AuditUtils.createAuditLog({
        userId: user.id,
        action: 'mfa_enabled',
        resource: 'user',
        details: { email: user.email },
        ipAddress: AuditUtils.getClientIP(req),
        userAgent: req.get('User-Agent'),
        success: true,
      }));

      const response: MfaSetupResponse = {
        success: true,
        backupCodes,
        message: 'MFA has been successfully enabled. Save your backup codes in a secure location.',
      };

      return res.json(response);
    } catch (error: any) {
      if (error.name === 'ZodError') {
        return sendError(res, 400, 'VALIDATION_ERROR', error.issues[0].message);
      }
      console.error('MFA verification error:', error);
      return sendError(res, 500, 'INTERNAL_ERROR', 'MFA verification failed');
    }
  }));

  /**
   * @swagger
   * /api/auth/mfa/disable:
   *   post:
   *     summary: Disable MFA for user
   *     tags: [MFA]
   *     security:
   *       - bearerAuth: []
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             properties:
   *               password:
   *                 type: string
   *               mfaCode:
   *                 type: string
   *     responses:
   *       200:
   *         description: MFA disabled
   */
  router.post('/mfa/disable', authLimiter, jwtAuth, asyncHandler(async (req: any, res) => {
    try {
      const validatedData = disableMfaSchema.parse(req.body);
      const user = await storage.getUserById(req.user.id);
      
      if (!user) {
        return sendError(res, 404, 'USER_NOT_FOUND', 'User not found');
      }

      if (!user.mfaEnabled) {
        return sendError(res, 400, 'MFA_NOT_ENABLED', 'MFA is not enabled');
      }

      // Verify current password
      if (!user.password || !(await PasswordUtils.verify(validatedData.password, user.password))) {
        return sendError(res, 401, 'INVALID_PASSWORD', 'Current password is incorrect');
      }

      // Verify MFA code
      const mfaValid = await storage.verifyMfaCode(user.id, validatedData.mfaCode);
      if (!mfaValid) {
        return sendError(res, 401, 'INVALID_MFA_CODE', 'Invalid MFA code');
      }

      // Disable MFA
      await storage.disableMfa(user.id);

      await storage.createAuditLog(AuditUtils.createAuditLog({
        userId: user.id,
        action: 'mfa_disabled',
        resource: 'user',
        details: { email: user.email },
        ipAddress: AuditUtils.getClientIP(req),
        userAgent: req.get('User-Agent'),
        success: true,
      }));

      return sendSuccess(res, null, 'MFA has been successfully disabled');
    } catch (error: any) {
      if (error.name === 'ZodError') {
        return sendError(res, 400, 'VALIDATION_ERROR', error.issues[0].message);
      }
      console.error('MFA disable error:', error);
      return sendError(res, 500, 'INTERNAL_ERROR', 'Failed to disable MFA');
    }
  }));

  /**
   * @swagger
   * /api/auth/mfa/backup-codes:
   *   post:
   *     summary: Generate new backup codes
   *     tags: [MFA]
   *     security:
   *       - bearerAuth: []
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             properties:
   *               password:
   *                 type: string
   *     responses:
   *       200:
   *         description: New backup codes generated
   */
  router.post('/mfa/backup-codes', authLimiter, jwtAuth, asyncHandler(async (req: any, res) => {
    try {
      const { password } = req.body;
      
      if (!password) {
        return sendError(res, 400, 'VALIDATION_ERROR', 'Password is required');
      }

      const user = await storage.getUserById(req.user.id);
      
      if (!user) {
        return sendError(res, 404, 'USER_NOT_FOUND', 'User not found');
      }

      if (!user.mfaEnabled) {
        return sendError(res, 400, 'MFA_NOT_ENABLED', 'MFA is not enabled');
      }

      // Verify current password
      if (!user.password || !(await PasswordUtils.verify(password, user.password))) {
        return sendError(res, 401, 'INVALID_PASSWORD', 'Current password is incorrect');
      }

      // Generate new backup codes
      const backupCodes = await storage.generateBackupCodes(user.id);

      await storage.createAuditLog(AuditUtils.createAuditLog({
        userId: user.id,
        action: 'backup_codes_generated',
        resource: 'user',
        details: { email: user.email },
        ipAddress: AuditUtils.getClientIP(req),
        userAgent: req.get('User-Agent'),
        success: true,
      }));

      return sendSuccess(res, { backupCodes }, 'New backup codes generated');
    } catch (error) {
      console.error('Backup codes error:', error);
      return sendError(res, 500, 'INTERNAL_ERROR', 'Failed to generate backup codes');
    }
  }));

  // ===================
  // PASSWORD MANAGEMENT
  // ===================

  /**
   * @swagger
   * /api/auth/forgot-password:
   *   post:
   *     summary: Request password reset
   *     tags: [Password]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             properties:
   *               email:
   *                 type: string
   *                 format: email
   *     responses:
   *       200:
   *         description: Password reset email sent
   */
  router.post('/forgot-password', strictLimiter, asyncHandler(async (req, res) => {
    try {
      const validatedData = forgotPasswordSchema.parse(req.body);
      
      const user = await storage.getUserByEmail(validatedData.email);
      
      // Always return success to prevent email enumeration
      if (!user) {
        return sendSuccess(res, null, 'If an account with that email exists, a password reset link has been sent.');
      }

      // Generate password reset token
      const resetToken = await storage.generatePasswordResetToken(user.id);

      // Send password reset email
      const emailService = getEmailService();
      await emailService.sendPasswordResetEmail(
        user.email!,
        user.firstName || 'User',
        resetToken
      );

      await storage.createAuditLog(AuditUtils.createAuditLog({
        userId: user.id,
        action: 'password_reset_requested',
        resource: 'user',
        details: { email: user.email },
        ipAddress: AuditUtils.getClientIP(req),
        userAgent: req.get('User-Agent'),
        success: true,
      }));

      return sendSuccess(res, null, 'If an account with that email exists, a password reset link has been sent.');
    } catch (error: any) {
      if (error.name === 'ZodError') {
        return sendError(res, 400, 'VALIDATION_ERROR', error.issues[0].message);
      }
      console.error('Forgot password error:', error);
      return sendError(res, 500, 'INTERNAL_ERROR', 'Failed to process request');
    }
  }));

  /**
   * @swagger
   * /api/auth/reset-password:
   *   post:
   *     summary: Reset password with token
   *     tags: [Password]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             properties:
   *               token:
   *                 type: string
   *               password:
   *                 type: string
   *                 minLength: 8
   *               confirmPassword:
   *                 type: string
   *     responses:
   *       200:
   *         description: Password reset successfully
   */
  router.post('/reset-password', authLimiter, asyncHandler(async (req, res) => {
    try {
      const validatedData = resetPasswordSchema.parse(req.body);
      
      // Verify reset token
      const user = await storage.verifyPasswordResetToken(validatedData.token);
      
      if (!user) {
        return sendError(res, 400, 'INVALID_TOKEN', 'Invalid or expired reset token');
      }

      // Reset password
      await storage.resetPassword(user.id, validatedData.password);

      // Invalidate all user sessions except current one
      await storage.deleteUserSessions(user.id);

      await storage.createAuditLog(AuditUtils.createAuditLog({
        userId: user.id,
        action: 'password_reset_completed',
        resource: 'user',
        details: { email: user.email },
        ipAddress: AuditUtils.getClientIP(req),
        userAgent: req.get('User-Agent'),
        success: true,
      }));

      // Send security alert email
      const emailService = getEmailService();
      await emailService.sendSecurityAlertEmail(
        user.email!,
        user.firstName || 'User',
        'Password Reset',
        AuditUtils.getClientIP(req),
        SessionUtils.parseUserAgent(req.get('User-Agent') || '')
      );

      return sendSuccess(res, null, 'Password has been reset successfully');
    } catch (error: any) {
      if (error.name === 'ZodError') {
        return sendError(res, 400, 'VALIDATION_ERROR', error.issues[0].message);
      }
      console.error('Reset password error:', error);
      return sendError(res, 500, 'INTERNAL_ERROR', 'Failed to reset password');
    }
  }));

  /**
   * @swagger
   * /api/auth/change-password:
   *   post:
   *     summary: Change password (authenticated user)
   *     tags: [Password]
   *     security:
   *       - bearerAuth: []
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             properties:
   *               currentPassword:
   *                 type: string
   *               newPassword:
   *                 type: string
   *                 minLength: 8
   *               confirmPassword:
   *                 type: string
   *     responses:
   *       200:
   *         description: Password changed successfully
   */
  router.post('/change-password', authLimiter, jwtAuth, asyncHandler(async (req: any, res) => {
    try {
      const validatedData = changePasswordSchema.parse(req.body);
      const user = await storage.getUserById(req.user.id);
      
      if (!user) {
        return sendError(res, 404, 'USER_NOT_FOUND', 'User not found');
      }

      // Verify current password
      if (!user.password || !(await PasswordUtils.verify(validatedData.currentPassword, user.password))) {
        return sendError(res, 401, 'INVALID_PASSWORD', 'Current password is incorrect');
      }

      // Update password
      await storage.updateUser(user.id, {
        password: validatedData.newPassword,
        updatedAt: new Date(),
      });

      // Invalidate all other sessions
      await storage.deleteUserSessions(user.id, req.user.sessionId);

      await storage.createAuditLog(AuditUtils.createAuditLog({
        userId: user.id,
        action: 'password_changed',
        resource: 'user',
        details: { email: user.email },
        ipAddress: AuditUtils.getClientIP(req),
        userAgent: req.get('User-Agent'),
        success: true,
      }));

      // Send security alert email
      const emailService = getEmailService();
      await emailService.sendSecurityAlertEmail(
        user.email!,
        user.firstName || 'User',
        'Password Changed',
        AuditUtils.getClientIP(req),
        SessionUtils.parseUserAgent(req.get('User-Agent') || '')
      );

      return sendSuccess(res, null, 'Password has been changed successfully');
    } catch (error: any) {
      if (error.name === 'ZodError') {
        return sendError(res, 400, 'VALIDATION_ERROR', error.issues[0].message);
      }
      console.error('Change password error:', error);
      return sendError(res, 500, 'INTERNAL_ERROR', 'Failed to change password');
    }
  }));

  // ===================
  // OAUTH ENDPOINTS
  // ===================

  /**
   * @swagger
   * /api/auth/google:
   *   get:
   *     summary: Initiate Google OAuth login
   *     tags: [OAuth]
   *     responses:
   *       302:
   *         description: Redirect to Google OAuth
   */
  router.get('/google', passport.authenticate('google', {
    scope: ['profile', 'email']
  }));

  /**
   * @swagger
   * /api/auth/google/callback:
   *   get:
   *     summary: Google OAuth callback
   *     tags: [OAuth]
   *     responses:
   *       302:
   *         description: Redirect after OAuth completion
   */
  router.get('/google/callback', 
    passport.authenticate('google', { session: false }),
    asyncHandler(async (req: any, res) => {
      if (!req.user) {
        return res.redirect('/login?error=oauth_failed');
      }

      // Generate JWT and session
      const sessionToken = SessionUtils.generateSessionId();
      const refreshToken = SessionUtils.generateRefreshToken();
      const expiresAt = SessionUtils.calculateExpiryTime(false);
      
      const session = await storage.createSession({
        userId: req.user.id,
        sessionToken,
        refreshToken,
        deviceInfo: SessionUtils.parseUserAgent(req.get('User-Agent') || ''),
        ipAddress: AuditUtils.getClientIP(req),
        userAgent: req.get('User-Agent') || '',
        expiresAt,
      });

      const accessToken = generateJWT(req.user, session.id);
      
      // Redirect with tokens (in production, use secure cookies)
      return res.redirect(`/?token=${accessToken}&refresh=${refreshToken}`);
    })
  );

  /**
   * @swagger
   * /api/auth/microsoft:
   *   get:
   *     summary: Initiate Microsoft OAuth login
   *     tags: [OAuth]
   *     responses:
   *       302:
   *         description: Redirect to Microsoft OAuth
   */
  router.get('/microsoft', passport.authenticate('microsoft', {
    scope: ['user.read']
  }));

  /**
   * @swagger
   * /api/auth/microsoft/callback:
   *   get:
   *     summary: Microsoft OAuth callback
   *     tags: [OAuth]
   *     responses:
   *       302:
   *         description: Redirect after OAuth completion
   */
  router.get('/microsoft/callback',
    passport.authenticate('microsoft', { session: false }),
    asyncHandler(async (req: any, res) => {
      if (!req.user) {
        return res.redirect('/login?error=oauth_failed');
      }

      // Generate JWT and session
      const sessionToken = SessionUtils.generateSessionId();
      const refreshToken = SessionUtils.generateRefreshToken();
      const expiresAt = SessionUtils.calculateExpiryTime(false);
      
      const session = await storage.createSession({
        userId: req.user.id,
        sessionToken,
        refreshToken,
        deviceInfo: SessionUtils.parseUserAgent(req.get('User-Agent') || ''),
        ipAddress: AuditUtils.getClientIP(req),
        userAgent: req.get('User-Agent') || '',
        expiresAt,
      });

      const accessToken = generateJWT(req.user, session.id);
      
      // Redirect with tokens (in production, use secure cookies)
      return res.redirect(`/?token=${accessToken}&refresh=${refreshToken}`);
    })
  );

  // ===================
  // SESSION MANAGEMENT
  // ===================

  /**
   * @swagger
   * /api/auth/sessions:
   *   get:
   *     summary: Get user's active sessions
   *     tags: [Session]
   *     security:
   *       - bearerAuth: []
   *     responses:
   *       200:
   *         description: List of active sessions
   */
  router.get('/sessions', generalLimiter, jwtAuth, asyncHandler(async (req: any, res) => {
    try {
      const sessions = await storage.getUserSessions(req.user.id);
      
      const sessionInfo = sessions.map(s => ({
        id: s.id,
        deviceInfo: s.deviceInfo || 'Unknown Device',
        ipAddress: s.ipAddress || 'Unknown',
        lastAccessed: s.lastAccessedAt,
        isCurrentSession: s.id === req.user.sessionId,
        createdAt: s.createdAt,
      }));

      return sendSuccess(res, sessionInfo);
    } catch (error) {
      console.error('Get sessions error:', error);
      return sendError(res, 500, 'INTERNAL_ERROR', 'Failed to fetch sessions');
    }
  }));

  /**
   * @swagger
   * /api/auth/sessions/{sessionId}:
   *   delete:
   *     summary: Terminate a specific session
   *     tags: [Session]
   *     security:
   *       - bearerAuth: []
   *     parameters:
   *       - name: sessionId
   *         in: path
   *         required: true
   *         schema:
   *           type: string
   *     responses:
   *       200:
   *         description: Session terminated
   */
  router.delete('/sessions/:sessionId', generalLimiter, jwtAuth, asyncHandler(async (req: any, res) => {
    try {
      const { sessionId } = req.params;
      
      // Verify session belongs to user
      const sessions = await storage.getUserSessions(req.user.id);
      const sessionToDelete = sessions.find(s => s.id === sessionId);
      
      if (!sessionToDelete) {
        return sendError(res, 404, 'SESSION_NOT_FOUND', 'Session not found');
      }

      await storage.deleteSession(sessionId);

      await storage.createAuditLog(AuditUtils.createAuditLog({
        userId: req.user.id,
        action: 'session_terminated',
        resource: 'user',
        details: { sessionId, deviceInfo: sessionToDelete.deviceInfo },
        ipAddress: AuditUtils.getClientIP(req),
        userAgent: req.get('User-Agent'),
        success: true,
      }));

      return sendSuccess(res, null, 'Session terminated successfully');
    } catch (error) {
      console.error('Delete session error:', error);
      return sendError(res, 500, 'INTERNAL_ERROR', 'Failed to terminate session');
    }
  }));

  /**
   * @swagger
   * /api/auth/sessions:
   *   delete:
   *     summary: Terminate all other sessions (logout from all devices)
   *     tags: [Session]
   *     security:
   *       - bearerAuth: []
   *     responses:
   *       200:
   *         description: All other sessions terminated
   */
  router.delete('/sessions', generalLimiter, jwtAuth, asyncHandler(async (req: any, res) => {
    try {
      const terminatedCount = await storage.deleteUserSessions(req.user.id, req.user.sessionId);

      await storage.createAuditLog(AuditUtils.createAuditLog({
        userId: req.user.id,
        action: 'all_sessions_terminated',
        resource: 'user',
        details: { terminatedCount },
        ipAddress: AuditUtils.getClientIP(req),
        userAgent: req.get('User-Agent'),
        success: true,
      }));

      return sendSuccess(res, { terminatedCount }, 'All other sessions terminated successfully');
    } catch (error) {
      console.error('Delete all sessions error:', error);
      return sendError(res, 500, 'INTERNAL_ERROR', 'Failed to terminate sessions');
    }
  }));

  /**
   * @swagger
   * /api/auth/logout:
   *   post:
   *     summary: Logout and terminate current session
   *     tags: [Authentication]
   *     security:
   *       - bearerAuth: []
   *     responses:
   *       200:
   *         description: Logged out successfully
   */
  router.post('/logout', generalLimiter, jwtAuth, asyncHandler(async (req: any, res) => {
    try {
      // Blacklist JWT
      const decoded = jwt.decode(req.get('Authorization')?.replace('Bearer ', '') || '') as any;
      if (decoded && decoded.jti) {
        await storage.blacklistJwt(decoded.jti, new Date(decoded.exp * 1000));
      }

      // Terminate session
      if (req.user.sessionId) {
        await storage.deleteSession(req.user.sessionId);
      }

      await storage.createAuditLog(AuditUtils.createAuditLog({
        userId: req.user.id,
        action: 'logout',
        resource: 'user',
        details: { sessionId: req.user.sessionId },
        ipAddress: AuditUtils.getClientIP(req),
        userAgent: req.get('User-Agent'),
        success: true,
      }));

      return sendSuccess(res, null, 'Logged out successfully');
    } catch (error) {
      console.error('Logout error:', error);
      return sendError(res, 500, 'INTERNAL_ERROR', 'Logout failed');
    }
  }));

  // ===================
  // EMAIL VERIFICATION
  // ===================

  /**
   * @swagger
   * /api/auth/verify-email:
   *   get:
   *     summary: Verify email address
   *     tags: [Email]
   *     parameters:
   *       - name: token
   *         in: query
   *         required: true
   *         schema:
   *           type: string
   *     responses:
   *       200:
   *         description: Email verified successfully
   */
  router.get('/verify-email', asyncHandler(async (req, res) => {
    try {
      const { token } = req.query;
      
      if (!token || typeof token !== 'string') {
        return sendError(res, 400, 'INVALID_TOKEN', 'Verification token is required');
      }

      const user = await storage.verifyEmailVerificationToken(token);
      
      if (!user) {
        return sendError(res, 400, 'INVALID_TOKEN', 'Invalid or expired verification token');
      }

      await storage.createAuditLog(AuditUtils.createAuditLog({
        userId: user.id,
        action: 'email_verified',
        resource: 'user',
        details: { email: user.email },
        success: true,
      }));

      return sendSuccess(res, null, 'Email verified successfully');
    } catch (error) {
      console.error('Email verification error:', error);
      return sendError(res, 500, 'INTERNAL_ERROR', 'Email verification failed');
    }
  }));

  /**
   * @swagger
   * /api/auth/resend-verification:
   *   post:
   *     summary: Resend email verification
   *     tags: [Email]
   *     security:
   *       - bearerAuth: []
   *     responses:
   *       200:
   *         description: Verification email sent
   */
  router.post('/resend-verification', authLimiter, jwtAuth, asyncHandler(async (req: any, res) => {
    try {
      const user = await storage.getUserById(req.user.id);
      
      if (!user) {
        return sendError(res, 404, 'USER_NOT_FOUND', 'User not found');
      }

      if (user.emailVerified) {
        return sendError(res, 400, 'EMAIL_ALREADY_VERIFIED', 'Email is already verified');
      }

      const verificationToken = await storage.generateEmailVerificationToken(user.id);
      
      const emailService = getEmailService();
      await emailService.sendEmailVerificationEmail(
        user.email!,
        user.firstName || 'User',
        verificationToken
      );

      return sendSuccess(res, null, 'Verification email sent successfully');
    } catch (error) {
      console.error('Resend verification error:', error);
      return sendError(res, 500, 'INTERNAL_ERROR', 'Failed to send verification email');
    }
  }));

  // ===================
  // ADMIN ENDPOINTS
  // ===================

  /**
   * @swagger
   * /api/auth/admin/users:
   *   get:
   *     summary: Get all users (admin only)
   *     tags: [Admin]
   *     security:
   *       - bearerAuth: []
   *     parameters:
   *       - name: search
   *         in: query
   *         schema:
   *           type: string
   *       - name: role
   *         in: query
   *         schema:
   *           type: string
   *       - name: isActive
   *         in: query
   *         schema:
   *           type: boolean
   *     responses:
   *       200:
   *         description: List of users
   */
  router.get('/admin/users', generalLimiter, jwtAuth, requirePermission('users.view'), asyncHandler(async (req: any, res) => {
    try {
      const { search, role, isActive } = req.query;
      
      const filters: any = {};
      if (search) filters.search = search as string;
      if (role) filters.role = role as string;
      if (isActive !== undefined) filters.isActive = isActive === 'true';

      const users = await storage.getUsers(filters);
      
      // Remove sensitive data
      const safeUsers = users.map(user => ({
        id: user.id,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        role: user.role,
        isActive: user.isActive,
        mfaEnabled: user.mfaEnabled,
        emailVerified: user.emailVerified,
        lastLoginAt: user.lastLoginAt,
        createdAt: user.createdAt,
      }));

      return sendSuccess(res, safeUsers);
    } catch (error) {
      console.error('Get users error:', error);
      return sendError(res, 500, 'INTERNAL_ERROR', 'Failed to fetch users');
    }
  }));

  /**
   * @swagger
   * /api/auth/admin/users/{userId}:
   *   put:
   *     summary: Update user (admin only)
   *     tags: [Admin]
   *     security:
   *       - bearerAuth: []
   *     parameters:
   *       - name: userId
   *         in: path
   *         required: true
   *         schema:
   *           type: string
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             properties:
   *               role:
   *                 type: string
   *                 enum: [admin, manager, user, viewer]
   *               isActive:
   *                 type: boolean
   *     responses:
   *       200:
   *         description: User updated successfully
   */
  router.put('/admin/users/:userId', authLimiter, jwtAuth, requirePermission('users.edit'), asyncHandler(async (req: any, res) => {
    try {
      const { userId } = req.params;
      const { role, isActive } = req.body;
      
      const user = await storage.getUserById(userId);
      if (!user) {
        return sendError(res, 404, 'USER_NOT_FOUND', 'User not found');
      }

      const updateData: any = {};
      if (role !== undefined) updateData.role = role;
      if (isActive !== undefined) updateData.isActive = isActive;

      const updatedUser = await storage.updateUser(userId, updateData);
      
      await storage.createAuditLog(AuditUtils.createAuditLog({
        userId: req.user.id,
        action: 'user_updated',
        resource: 'user',
        resourceId: userId,
        details: { changes: updateData, targetEmail: user.email },
        ipAddress: AuditUtils.getClientIP(req),
        userAgent: req.get('User-Agent'),
        success: true,
      }));

      const safeUser = updatedUser ? {
        id: updatedUser.id,
        email: updatedUser.email,
        firstName: updatedUser.firstName,
        lastName: updatedUser.lastName,
        role: updatedUser.role,
        isActive: updatedUser.isActive,
        mfaEnabled: updatedUser.mfaEnabled,
        emailVerified: updatedUser.emailVerified,
        lastLoginAt: updatedUser.lastLoginAt,
        createdAt: updatedUser.createdAt,
      } : null;

      return sendSuccess(res, safeUser, 'User updated successfully');
    } catch (error) {
      console.error('Update user error:', error);
      return sendError(res, 500, 'INTERNAL_ERROR', 'Failed to update user');
    }
  }));

  /**
   * @swagger
   * /api/auth/admin/stats:
   *   get:
   *     summary: Get user statistics (admin only)
   *     tags: [Admin]
   *     security:
   *       - bearerAuth: []
   *     responses:
   *       200:
   *         description: User statistics
   */
  router.get('/admin/stats', generalLimiter, jwtAuth, requirePermission('system.view_analytics'), asyncHandler(async (req: any, res) => {
    try {
      const stats = await storage.getUserStats();
      return sendSuccess(res, stats);
    } catch (error) {
      console.error('Get stats error:', error);
      return sendError(res, 500, 'INTERNAL_ERROR', 'Failed to fetch statistics');
    }
  }));

  /**
   * @swagger
   * /api/auth/admin/audit-logs:
   *   get:
   *     summary: Get audit logs (admin only)
   *     tags: [Admin]
   *     security:
   *       - bearerAuth: []
   *     parameters:
   *       - name: userId
   *         in: query
   *         schema:
   *           type: string
   *       - name: action
   *         in: query
   *         schema:
   *           type: string
   *       - name: limit
   *         in: query
   *         schema:
   *           type: integer
   *           default: 100
   *     responses:
   *       200:
   *         description: Audit logs
   */
  router.get('/admin/audit-logs', generalLimiter, jwtAuth, requirePermission('system.view_audit_logs'), asyncHandler(async (req: any, res) => {
    try {
      const { userId, action, limit } = req.query;
      
      const logs = await storage.getAuditLogs(
        userId as string,
        action as string,
        limit ? parseInt(limit as string) : 100
      );

      return sendSuccess(res, logs);
    } catch (error) {
      console.error('Get audit logs error:', error);
      return sendError(res, 500, 'INTERNAL_ERROR', 'Failed to fetch audit logs');
    }
  }));

  app.use('/api/auth', router);
}